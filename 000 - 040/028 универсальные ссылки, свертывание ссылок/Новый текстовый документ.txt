
https://habr.com/ru/articles/646005/#id-3-2

3.2.3. Универсальные ссылки и rvalue-ссылки

Универсальная ссылка и rvalue-ссылка объявляются одинаково, с помощью спецификатора &&, поэтому важно четко понимать, с каким вариантом мы имеем дело в том или ином случае.

Универсальная ссылка — это не особая разновидность ссылок, а некоторый специальный механизм автоматического вывода аргумента шаблона и для того чтобы он был использован, необходимо выполнение трех условий.

Наличие шаблона функции с типовым параметром (обозначим его через T).
Параметр функции объявлен как T&&.
Аргумент шаблона выводится автоматически, исходя из типа аргумента вызова функции.

Если аргумент шаблона задается явно и параметр шаблона функции объявлен как T&&, то в случае аргумента шаблона ссылочного типа применяется свертывание ссылок (см. раздел 5.2.2) и параметр конкретизированной функции превратится в обычную ссылку или rvalue-ссылку. Если аргумент шаблона нессылочного типа, то параметр будет rvalue-ссылка.

Рассмотрим примеры.

class X
{
public:
    X();
// ...
};

X x; // x это lvalue

Рассмотрим несколько вариантов использования x в качестве аргумента при вызове функции.

void F(X&& x);

F(x); // ошибка

В данном случае у нас обычная функция (нарушено условие 1), параметр имеет тип rvalue-ссылка, lvalue-аргумент не подходит.

template<typename T>
void Foo(T&& x)

Foo(x); // OK

В данном случае все условия выполнены, параметр является универсальной ссылкой, можно использовать lvalue-аргумент.

Foo<X>(x); // ошибка

Аргумент шаблона задается явно, параметр в данном случае имеет тип rvalue-ссылка, lvalue-аргумент не подходит.

Foo<X&>(x); // OK

Аргумент шаблона задается явно и имеет ссылочный тип, следовательно выполняется свертывание ссылок (X& && -> X&). Параметр будет обычной ссылкой, поэтому можно использовать lvalue-аргумент.

template<typename T>
class W
{
public:
    W();
    void Foo1(T&& x);
    template<typename U>
    void Foo2(U&& x);
// ...
};

W<X> wx;
wx.Foo1(x);  // ошибка

Тип параметра функции-члена Foo1() определяется явно, при конкретизации шаблона класса W, параметр имеет тип rvalue-ссылка, lvalue-аргумент не подходит.

W<X&> wrx;
wrx.Foo1(x); // OK

Тип параметра функции-члена Foo1() определяется явно, при конкретизации шаблона класса W, аргумент шаблона класса имеет ссылочный тип, следовательно выполняется свертывание ссылок (X& && -> X&). Параметр будет обычной ссылкой, поэтому можно использовать lvalue-аргумент.

W<X> wx;
wx.Foo2(x);

Здесь мы имеем шаблон функции-члена. В этом вызове аргумент шаблона функции-члена выводится автоматически, параметр будет универсальной ссылкой, поэтому можно использовать lvalue-аргумент.

Таким образом, если параметр функции выглядит как T&&, то при конкретизации шаблона он может превратиться в обычную ссылку или rvalue-ссылку. Это происходит как при автоматическом выводе аргумента шаблона, так и при явном его задании, но при автоматическом выводе у нас нет ограничений на категорию значения аргумента.

Универсальные ссылки также используются при выводе типа переменных, объявленных с помощью auto &&. Это происходит при объявлении переменных (см. раздел 2.5) и параметров лямбда-выражений (см. раздел 3.4.1).